在生产环境下，为了提高页面加载性能，构建工具一般会将项目的代码打包(bundle)到一起，这样上线之后只需要请求少量的JS文件，大大减少了HTTP请求。vite也不例外，默认情况下Vite利用底层引擎Rollup来完成项目的模块打包。

某种意义上来说，对线上环境进行项目打包是一个必须的操作。但随着前端工程的日渐复杂，单份的打包产物体积越来越庞大，会出现一系列应用加载性能问题，而代码分割可以很好地解决它们。

- `bundle`指的是整体的打包产物，包含JS和各种静态资源。
- `chunk`指的是打包后的JS文件，是`bundle`的子集。
- `vendor`

### Code Splitting 解决的问题

在传统的单chunk打包模式下，当项目代码越来越庞大，最后会导致浏览器下载一个巨大的文件，从页面加载性能的角度来说，主要会导致两个问题：

- 无法做到按需加载，即使是当前页面不需要的代码也会进行加载。
- 线上缓存复用率极低，改动一行代码即可导致整个bundle产物缓存失败。

一般而言，一个前端页面中的JS代码可以分为两个部分：`Initital`、`Chunk`和`Async Chunk`，前者指页面首屏所需要的JS代码，而后者当前页面并不一定需要，一个典型的例子就是`路由组件`，与当前路由无关的组件并不用加载。而项目被打包成单bundle之后，无论`Initial Chunk`还是`Async Chunk`，都会打包进同一个产物，也就是说，浏览器加载产物代码的时候，会将两者一起加载，导致许多冗余代码的加载过程，使页面性能得到提升。

其次，线上的`缓存命中率`是一个重要的性能衡量标准。对于线上站点而言，服务端一般在响应资源加上一些HTTP响应头，最常见的响应头之一就是`cache-control`，它可以指定浏览器的强缓存，比如：

```bash
cache-control:max-age=3153600
```

表示资源过期时间为一年，在过期之前，访问相同的资源url，浏览器直接利用本地的缓存，并不用给服务端发请求，这就大大降低了页面加载的网络开销。不过，在单chunk打包模式下，一旦有一行代码改动过，整个chunk的url地址都会变化。

由于构建工具一般会根据产物的内容生成哈希值，一旦内容改变就会导致整个chunk产物的强缓存失效，所以单个chunk打包模式下单缓存命中率极低，基本为零。

我们可以通过`Code Splitting`将chunck拆得尽可能得小，这样缓存命中率也会大大的提高。